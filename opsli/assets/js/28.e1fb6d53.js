(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{695:function(e,n,a){"use strict";a.r(n);var t=a(14),i=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"什么事应用程序的高可用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么事应用程序的高可用"}},[e._v("#")]),e._v(" 什么事应用程序的高可用")]),e._v(" "),a("p",[e._v("高可用性(high availability)通常用来描述一个系统经过专门的设计,从而减少停工的时间,而保持其服务的高度可用性")]),e._v(" "),a("p",[e._v("++说白了，就是保障服务器应用红旗不倒++")]),e._v(" "),a("h3",{attrs:{id:"前提"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前提"}},[e._v("#")]),e._v(" 前提")]),e._v(" "),a("blockquote",[a("p",[e._v("服务器如果采用Nginx 作为负载均衡\n例如以下情况：\n-- Nginx服务器0"),a("br"),e._v("\n---- ->  APP应用服务器1\n---- ->  APP应用服务器2")])]),e._v(" "),a("p",[e._v("如果 Nginx负载服务器0 宕机了，那么APP1/APP2 两台服务器 也就被迫为不可用状态，但是实际上是可用的")]),e._v(" "),a("p",[e._v("如果对于要求服务高可用的公司来说，这就成了严重的单点故障")]),e._v(" "),a("p",[e._v("++解决思路是 增加一台备用Nginx服务器，当主Nginx负载服务器宕机后，备用机毫秒级瞬间顶上去++")]),e._v(" "),a("p",[e._v("图例：\n"),a("img",{attrs:{src:"https://bedebug.com/upload/2020/04/keepalived-405481c959ec4db3b7a33255f6568097.jpg",alt:"keepalived"}})]),e._v(" "),a("h3",{attrs:{id:"lvs-keepalived-保障ha高可用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lvs-keepalived-保障ha高可用"}},[e._v("#")]),e._v(" Lvs+Keepalived 保障HA高可用")]),e._v(" "),a("blockquote",[a("p",[e._v("跳转至 https://bedebug.com/archives/ha2")])]),e._v(" "),a("h3",{attrs:{id:"安装-keepalived-主备负载服务器都需要安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装-keepalived-主备负载服务器都需要安装"}},[e._v("#")]),e._v(" 安装 Keepalived (主备负载服务器都需要安装)")]),e._v(" "),a("p",[e._v("yum install keepalived  -y")]),e._v(" "),a("h4",{attrs:{id:"修改-keepalived-conf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改-keepalived-conf"}},[e._v("#")]),e._v(" 修改 keepalived.conf")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\tcd  /etc/keepalived/\n\tcp keepalived.conf keepalived.conf.bak\n\tvi keepalived.conf\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[a("strong",[e._v("主服务器 MASTER")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('! Configuration File for keepalived \n \nglobal_defs { \n   ## keepalived 自带的邮件提醒需要开启 sendmail 服务。建议用独立的监控或第三方 SMTP \n   router_id TS1  ## 标识本节点的字条串，通常为 hostname \n} \n##  keepalived 会定时执行脚本并对脚本执行的结果进行分析，动态调整 vrrp_instance 的优先级。如果脚本执行结果为 0，并且 weight 配置的值大于 0，则优先级相应的增加。如果脚本执行结果非 0，并且 weight配置的值小于 0，则优先级相应的减少。其他情况，维持原本配置的优先级，即配置文件中 priority 对应的值。 \nvrrp_script chk_nginx { \n    script "/etc/keepalived/nginx_check.sh"  ## 检测 nginx 状态的脚本路径 \n    interval 2  ## 检测时间间隔 \n    weight -20  ## 如果条件成立，权重-20  \n} \n## 定义虚拟路由，VI_1 为虚拟路由的标示符，自己定义名称 \nvrrp_instance VI_1 { \n    state MASTER  ## 主节点为 MASTER，对应的备份节点为 BACKUP \n    interface eth0  ## 绑定虚拟 IP 的网络接口，与本机 IP 地址所在的网络接口相同，我的是 eth1 \n    virtual_router_id 51  ## 虚拟路由的 ID 号，两个节点设置必须一样，可选 IP 最后一段使用,  相同的 VRID 为一个组，他将决定多播的 MAC 地址 \n    mcast_src_ip 192.0.0.2  ## 本机 IP 地址 \n    unicast_peer {\n    \t192.0.0.3 ##（对端IP地址）此地址一定不能忘记\n    }\n    priority 100  ## 节点优先级，值范围 0-254，MASTER 要比BACKUP 高 \n    nopreempt ## 优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题 \n    advert_int 1  ## 组播信息发送间隔，两个节点设置必须一样，默认 1s \n    ## 设置验证信息，两个节点必须一致 \n\n    ## 将 track_script 块加入instance 配置块 \n    track_script { \n        chk_nginx  ## 执行 Nginx 监控的服务 \n    } \n    ## 虚拟 IP 池, 两个节点设置必须一样 \n    ## 很重要 是虚拟出来的一个独立IP\n    ## 两个服务器 互相监控 发现宕机 则把这个IP拿来做自己的一块虚拟网卡\n## 公网映射需要 映射到这块 虚拟网卡上\t\n    virtual_ipaddress { \n        192.0.0.1/24   dev  eth0  label  eth0:2\n    } \n}\n')])])]),a("p",[a("strong",[e._v("备用服务器 BACKUP")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('! Configuration File for keepalived\n\nglobal_defs {\n  # notification_email {\n   #  acassen@firewall.loc\n   #  failover@firewall.loc\n   #  sysadmin@firewall.loc\n #  }\n#   notification_email_from Alexandre.Cassen@firewall.loc\n #  smtp_server 192.168.200.1\n  # smtp_connect_timeout 30\n   router_id ts2\n}\n\nvrrp_script chk_nginx {\n    script "/etc/keepalived/nginx_check.sh"  ## 检测 nginx 状态的脚本路径\n    interval 2  ## 检测时间间隔\n    weight -20  ## 如果条件成立，权重-20\n}\n\nvrrp_instance VI_1 {\n    state BACKUP\n    interface eth0\n    virtual_router_id 51\n    priority 90\n    advert_int 1\n\n    mcast_src_ip 192.0.0.3\n    \n    unicast_peer {\n    \t192.0.0.2 ##（对端IP地址）此地址一定不能忘记\n    }\n    \n    track_script {\n    chk_nginx\n    }\n\n    authentication {\n        auth_type PASS\n        auth_pass 1111\n    }\n    virtual_ipaddress {\n        192.0.0.1/24   dev  eth0  label  eth0:2\n    }\n}\n')])])]),a("p",[a("strong",[e._v("状态检查脚本")])]),e._v(" "),a("p",[e._v("编写nginx状态检查脚本/etc/keepalived/nginx_check.sh")]),e._v(" "),a("p",[e._v("在Keepalived配置中已用。脚本要求：如果 nginx 停止运行，尝试启动，如果无法启动则杀死本机的 keepalived 进程， keepalied将虚拟 ip 绑定到 BACKUP 机器上。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("vi /etc/keepalived/nginx_check.sh\n")])])]),a("p",[a("strong",[e._v("内容")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("#!/bin/bash \nA=`ps -C nginx –no-header |wc -l` \nif [ $A -eq 0 ];then \n    # Nginx 安装路径 -> 到 sbin/nginx\n    /usr/local/nginx/sbin/nginx \n    sleep 2 \n    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then\n        killall keepalived \n    fi \nfi\n")])])]),a("p",[a("strong",[e._v("权限")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("chmod +x /etc/keepalived/nginx_check.sh\n")])])]),a("h3",{attrs:{id:"安装-nginx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装-nginx"}},[e._v("#")]),e._v(" 安装 Nginx")]),e._v(" "),a("blockquote",[a("p",[e._v("跳转至 https://bedebug.com/archives/nginx1")])])])}),[],!1,null,null,null);n.default=i.exports}}]);